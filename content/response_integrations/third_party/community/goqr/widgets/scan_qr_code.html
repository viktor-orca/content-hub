<!-- Widget created by List Response Template / Version 1.0 / 2025-04-28 -->
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700,700i" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css?family=Source Sans Pro" rel="stylesheet"/>
  <title>
   GOQR - Scan QR Code
  </title>
  <style>
   /* Root Variables */
    :root {
      --widget-bg: rgb(33, 44, 68);
      --widget-font-family: 'Source Sans Pro', sans-serif;
      --widget-text-color: rgb(255, 255, 255);
      --widget-scrollbar-size: 12px;
      --widget-row-highlight-bg: rgb(47 61 91);

      /*Logo styles*/
      --logo-size: 48px;
      --logo-color: rgb(255, 255, 255);
      /*Logo styles*/

      /*Table styles*/
      --table-color-even-row: rgb(26 32 50);
      --table-title-size: 600 14px/18px var(--widget-font-family);
      --table-th-size: 600 14px/18px var(--widget-font-family);
      --table-td-size: 400 14px/18px var(--widget-font-family);
    }

    /*Normalize CSS */
    * {
      margin: 0;
      padding: 0;
      outline: none;
      box-sizing: border-box;
    }

    *:hover, *:focus, *:active {
      outline: none;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      border-spacing: 0;
    }

    ol, ul {
      list-style: none;
    }

    button,
    input,
    textarea {
      font-family: inherit;
      background: transparent;
      border: 0;
      color: inherit;
      text-align: left;
    }

    button, a[href] {
      cursor: pointer;
    }

    /*Normalize CSS */
    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 18px;
      height: 18px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(137, 151, 180, 1);
      border: 6px solid var(--widget-bg);
      border-radius: 63px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
      border: 4px solid transparent;
      border-radius: 44px;
    }

    ::-webkit-scrollbar-corner {
      background-color: transparent;
      border-color: transparent;
    }

    body {
      font-family: var(--widget-font-family), serif;
      color: var(--widget-text-color);
      background-color: var(--widget-bg);
      overflow: hidden;
    }

    /*Global styles*/
    .text-ellipsis {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tooltip {
      max-width: 100%;
      position: absolute;
      padding: 8px 16px 8px 16px;
      border-radius: 4px;
      background-color: rgb(204 204 218);
      color: rgb(22, 22, 37);
      font: 400 14px/18px var(--widget-font-family);
      z-index: 99;
      word-wrap: break-word;
    }

    .tooltip-triangle {
      position: absolute;
      top: 100%;
      border-top: solid 8px rgb(195, 210, 232);
      border-left: solid 8px transparent;
      border-right: solid 8px transparent;
    }

    .input {
      border: 1px solid #6275A3;
      border-radius: 4px;
      padding: 4px 8px;
      background-color: transparent;
      font-size: 14px;
      color: var(--widget-text-color);
    }

    .input::placeholder {
      color: var(--widget-text-color);
    }

    input[type="checkbox"] {
      max-width: 13px;
      max-height: 13px;
    }

    /*Global styles*/

    /*Table*/
    .table-wrapper {
      margin-top: 8px;
      position: relative;
    }

    .table-search {
      display: flex;
      justify-content: flex-end;
    }

    .table-container {
      overflow: auto;
      max-height: calc(100vh - 102px);
    }

    .table {
      table-layout: fixed;
    }

    .table thead {
      position: sticky;
      top: 0;
      z-index: 9;
    }

    .table th {
      width: 250px;
      background-color: var(--widget-row-highlight-bg);
      color: var(--widget-text-color);
      font: var(--table-th-size);
      padding: 6px 12px;
      text-transform: uppercase;
      vertical-align: top;
      text-align: left;
    }

    .table tr:nth-child(even) {
      background-color: var(--table-color-even-row);
    }

    .table-resizable-line {
      position: absolute;
      inset: 3px 6px 3px auto;
      width: 2px;
      cursor: col-resize;
      user-select: none;
      background-color: rgb(98, 117, 163);
      z-index: 9;
    }

    .table-resizable-line::before, .table-resizable-line::after {
      content: '';
      position: absolute;
      inset: 0 auto;
      width: 6px;
    }

    .table-resizable-line::before {
      left: -6px;
    }

    .table-resizable-line::after {
      right: -6px;
    }

    .table td {
      padding: 8px 12px;
      font: var(--table-td-size);
      color: var(--widget-text-color);
      vertical-align: top;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      min-width: var(--logo-size);
      min-height: var(--logo-size);
      max-width: var(--logo-size);
      max-height: var(--logo-size);
      color: var(--logo-color);
    }

    .counter {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 0 auto;
    }

    .counter-number {
      font: 600 20px/24px var(--widget-font-family);
      text-align: center;
    }

    .counter-title {
      font: 600 16px/22px var(--widget-font-family);
      text-transform: uppercase;
      text-align: center;
    }

    .table-events {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: flex-end;
      margin-bottom: 12px;
      padding: 0 6px;
    }

    .table-udm-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding-left: 4px;
      cursor: pointer;
    }

    .table-udm-label-text {
      font-size: 14px;
    }

    /* Dropdown */
    .dropdown-button {
      width: 24px;
      height: 24px;
      cursor: pointer;
    }

    .dropdown-container {
      width: 24px;
      height: 24px;
      margin-right: auto;
      position: relative;
    }

    .dropdown {
      position: absolute;
      top: 100%;
      background-color: var(--widget-bg);
      min-width: 270px;
      max-width: 280px;
      padding: 12px 16px;
      z-index: 99;
      box-shadow: 0 4px 6px 3px rgba(0, 0, 0, 0.6);
      border-radius: 4px;
      flex-direction: column;
      display: none;
    }

    @media (max-height: 400px) {
      .dropdown {
        max-height: 280px;
      }
    }

    .dropdown.show {
      display: flex;
    }

    .dropdown-list {
      margin-top: 12px;
      margin-right: -15px;
      max-height: 300px;
      overflow: auto;
    }

    .dropdown-events {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .dropdown-search {
      width: 100%;
    }

    .dropdown-list-select {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }

    .dropdown-list-select-text {
      font-size: 14px;
      white-space: nowrap;
    }

    .dropdown-list-label {
      display: flex;
      align-items: center;
      gap: 6px;
      width: 100%;
      cursor: pointer;
      padding: 12px 0;
    }
  </style>
 </head>
 <body>
  <div class="header">
   <div class="counter">
    <h1 class="counter-number" id="counterNumber">
    </h1>
    <h2 class="counter-title" id="counterTitle">
    </h2>
   </div>
   <svg class="logo" fill="currentColor" id="Layer_1" style="enable-background:new 0 0 25 25;" version="1.1" viewbox="0 0 25 25" x="0px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" y="0px">
    <g>
     <g>
      <path d="M16.7,16.2c-2.1,0.2-3.4-0.9-4.4-1.5c1.7,1.5,3,2.9,3.6,3.6c-0.5-0.1-1-0.4-1.4-0.7c0.6,0.8,1.4,1.6,2.3,2
			c0,0-0.4,0-0.8-0.1c1,0.8,1.6,0.5,2,0.3c0.5,1.4,1.3,1.3,1.6,1.3c-1.1-0.4-0.8-1.3,0.2-1.5c1-0.1,1.1,0.6,1.1,1
			c0.5-1.3,0.1-1.3-1-1.4c-1-0.1-1.3-0.5-1.5-0.8c0.5,0.1,1,0,2.1-0.5c1.1-0.6,2-0.4,2.5-0.4C20.2,15.5,18.8,16,16.7,16.2z
			 M10.2,14.8c-1.6,0.1-3.2-1-4-1.6c1.1,1.4,2.8,2.3,4.5,2.7c1.7,0.4,2,0.5,3.3,1.1c-2.5-2.5-4.4-3-5-3.2
			C9.5,14.1,9.9,14.4,10.2,14.8z M6.4,8.6c1.4,1,3.3,1.6,4.7,3.5c-0.3-1-0.9-2.2-3.8-4.1C5.8,7.1,3.7,6,1,3C1.2,3.8,2.1,5.9,6.4,8.6
			z M11.2,13.5c-0.4-0.8-1.1-1.9-3.9-3.4C6.1,9.4,3.8,8.3,1.9,6.2C2,7,3,8.7,6.9,10.7C8,11.3,9.9,11.9,11.2,13.5z M23.1,16.2
			c0.1-1-2.2-1.4-3-1.7c-0.2-0.1-0.6-0.2-0.2-1c0.5-1.2,1-2.3-5.8-4.2C8.5,7.7,6.3,5.8,4.6,3.7c0.8,2.4,2.6,3.2,4.6,4.8
			c2,1.6,2.1,2.5,2.6,3.4c1.3,2.1,1.5,2.4,2.8,3.4c1.5,1,3.3,0.3,5.3,0.6c2,0.3,3.6,1.8,4,2.4C24.3,17.6,23.3,16.5,23.1,16.2z
			 M21.8,15.7c1,0.2,1,0.4,1,0.8C22.4,16,21.8,15.7,21.8,15.7z">
      </path>
     </g>
    </g>
   </svg>
  </div>
  <div class="table-wrapper" id="tableWrapper">
   <div class="table-events">
    <div class="dropdown-container">
     <svg class="dropdown-button" fill="currentColor" height="24" id="columnsIcon" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path d="M4 6v12.444h16V6H4zm4.738 10.667h-2.96v-8.89h2.96v8.89zm4.746 0h-2.96v-8.89h2.96v8.89zm4.738 0h-2.96v-8.89h2.96v8.89z">
      </path>
     </svg>
     <div class="dropdown" id="dropdown">
      <div class="dropdown-events">
       <input class="input dropdown-search" id="dropdownSearch" placeholder="Search (regex)" type="text"/>
       <label class="dropdown-list-select" for="selectAll">
        <span class="dropdown-list-select-text" id="selectAllText">
        </span>
        <input checked="" id="selectAll" type="checkbox"/>
       </label>
      </div>
      <div class="dropdown-list" id="dropdownList">
      </div>
     </div>
    </div>
    <label class="table-udm-label" for="predefinedFieldsCheckbox" id="predefinedFieldsCheckboxLabel">
     <input id="predefinedFieldsCheckbox" type="checkbox"/>
     <span class="table-udm-label-text">
      Preselected Fields
     </span>
    </label>
    <input autocomplete="off" class="input table-search" id="searchInput" placeholder="Search (regex)" type="text"/>
   </div>
   <div class="table-container">
    <table class="table">
     <thead id="tableHeader">
     </thead>
     <tbody id="tableBody">
     </tbody>
    </table>
   </div>
  </div>
  <script>
   // JSON placeholder [{stepInstanceName}.JsonResult]
  const actionListData = [[{stepInstanceName}.JsonResult]];

  // Create a new array, 'specifiedKeys', by mapping over an existing array.
  const specifiedKeys = [].map(key => key.replace(/[\W_]/g, "").toLowerCase());

  // Set to "true" to have with specifiedKeys on initial load
  predefinedFieldsCheckbox.checked = false;

  // Constants and let for tooltip positioning
  const tooltipGap = 25;
  const tooltipTriangleHeight = 8;
  const tooltipTriangleMinGap = 5;
  const triangleWidth = 16;
  let tooltipTimeout = undefined;

  // Extract keys and values from actionListData
  const allKeys = getAllKeys(actionListData);
  const allValues = getAllValues(actionListData);

  // Modify keys for uniformity and prepare for filtering
  const modifiedAllKeys = allKeys.map(key => key.replace(/^udm\./, "").replace(/[\W_]/g, "").toLowerCase());

  // Initialize arrays and objects for processing
  const specifiedKeysInAll = [];
  const allKeysRecords = {};

  // Track the dropdown open/close state
  let dropdownIsOpen = false;

  // Populate specifiedKeysInAll and allKeysRecords
  modifiedAllKeys.forEach((key, index) => {
    const keyInAll = allKeys[index];
    allKeysRecords[keyInAll] = index;
    if (specifiedKeys.includes(key)) {
      specifiedKeysInAll.push(keyInAll);
    }
  });

  // Event listeners for UI interactions
  columnsIcon.addEventListener("click", function (event) {
    dropdown.classList.toggle("show");
    if (!dropdownIsOpen) {
      dropdownSearch.value = "";
      filterDropdown();
    }
    dropdownIsOpen = !dropdownIsOpen;
    event.stopPropagation();
  });
  document.addEventListener("click", function (event) {
    if (!dropdown.contains(event.target) && event.target !== columnsIcon) {
      dropdown.classList.remove("show");
      dropdownSearch.value = "";
      filterDropdown();
      dropdownIsOpen = false;
    }
  });
  dropdownSearch.addEventListener("input", debounce(filterDropdown, 300));
  searchInput.addEventListener("input", debounce(generateTable, 500));
  selectAll.addEventListener("change", function () {
    getDropdownListCheckboxes().forEach(function (checkbox) {
      checkbox.checked = selectAll.checked;
    });
    generateTable();
  });
  predefinedFieldsCheckbox.addEventListener("change", () => {
    generateDropdown();
    generateTable();
  });
  const tooltipDetectResizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      const target = entry.target;
      if (target) {
        const {offsetWidth, scrollWidth} = target;
        if (scrollWidth > offsetWidth) {
          target.addEventListener("mouseover", createTooltipListener);
          target.addEventListener("mouseout", removeTooltipListener);
        } else {
          target.removeEventListener("mouseover", createTooltipListener);
          target.removeEventListener("mouseout", removeTooltipListener);
        }
      }
    }
  });

  // Generate dropdown on page load
  generateDropdown();

  if (specifiedKeys.length === 0) {
    predefinedFieldsCheckboxLabel.remove();
  }

  /**
   * Function to get selected column indexes
   */
  function getSelectedColumnsIndexes() {
    const selectedCheckBoxes = getDropdownListCheckboxes().filter(checkbox => !!checkbox.checked);
    return selectedCheckBoxes.map(checkbox => allKeysRecords[checkbox.value]);
  }

  function escapeRegExp(string) {
    return string.replace(/([+])/g, "\\$1");
  }

  /**
   * Generates the table based on current selections and filters.
   */
  function generateTable() {
    const searchQuery = getSearchValue();
    const selectedColumnIndexes = getSelectedColumnsIndexes();
    const isSelectAll = selectedColumnIndexes.length === allKeys.length;
    const rowValues = isSelectAll ? allValues : allValues.map(rowData => rowData.filter((data, index) => selectedColumnIndexes.includes(index))).filter(rowData => rowData.length > 0);
    const escapedQuery = escapeRegExp(searchQuery);
    const regexPattern = new RegExp(escapedQuery, "gi");

    generateTableHeader(isSelectAll ? undefined : selectedColumnIndexes);

    if (!searchQuery) {
      generateTableBody(rowValues);
    } else {
      const filteredRows = rowValues.filter(item =>
        item.some(value =>
          (typeof value === "string" && regexPattern.test(value)) ||
          (typeof value === "number" && regexPattern.test(value.toString())),
        ),
      );
      generateTableBody(filteredRows, searchQuery);
    }
  }

  /**
   * Generates the table header based on selected columns.
   */
  function generateTableHeader(indexesToRender) {
    let keysToRender = allKeys;
    tableHeader.innerHTML = "";
    if (Array.isArray(indexesToRender)) {
      if (indexesToRender.length === 0) {
        return;
      }
      keysToRender = allKeys.filter((key, index) => indexesToRender.includes(index));
    }
    const table_tr = document.createElement("tr");
    keysToRender.forEach((key) => {
      const table_th = document.createElement("th");
      const table_th_div = document.createElement("div");
      renderWithTooltip(table_th_div, key.replace(/\./g, "."));
      table_th.appendChild(table_th_div);
      table_tr.appendChild(table_th);
      tableHeader.appendChild(table_tr);
    });

    resizableGrid();
  }

  /**
   * Generates the table body based on rows to render and search query.
   */
  function generateTableBody(rowsToRender, searchQuery = "") {
    tableBody.innerHTML = "";

    const escapedQuery = escapeRegExp(searchQuery);
    const regexPattern = new RegExp(escapedQuery, "gi");

    rowsToRender.forEach(item => {
      const row = document.createElement("tr");
      item.forEach(value => {
        const cell = document.createElement("td");
        renderWithTooltip(cell, value);
        if (typeof value === "string" && searchQuery && regexPattern.test(value)) {
          cell.innerHTML = value.replace(regexPattern, match => `<mark style="pointer-events: none">${match}</mark>`);
        } else if (typeof value === "number" && searchQuery && regexPattern.test(value.toString())) {
          cell.innerHTML = value.toString().replace(regexPattern, match => `<mark style="pointer-events: none">${match}</mark>`);
        } else if (value === undefined || value === null || value === "") {
          cell.textContent = "N/A";
        } else {
          cell.textContent = value;
        }
        row.appendChild(cell);
      });
      tableBody.appendChild(row);
    });

    updateCounter();
  }

  /**
   * Updates the counter displaying the number of rows in the table.
   */
  function updateCounter() {
    const rowCount = tableBody.rows.length;
    counterTitle.innerText = rowCount === 1 ? "Record found" : "Records found";
    counterNumber.innerText = rowCount;
  }

  /**
   * Retrieves all unique keys from nested data structures.
   */
  function getAllKeys(data) {
    const allKeys = new Set();
    const prePathMaxIndexesMap = new Map();

    function traverse(obj, path = "") {
      for (const key in obj) {
        if (Array.isArray(obj[key])) {
          if (obj[key].length === 0) {
            allKeys.add(`${path}${key}`);
          }
          obj[key].forEach((item, index) => {
            if (typeof item === "object" && item !== null) {
              traverse(item, `${path}${key}.${index}.`);
            } else {
              const prePath = `${path}${key}`;
              if (!allKeys.has(prePath)) allKeys.add(prePath);
              else {
                const currentMaxIndex = prePathMaxIndexesMap.get(prePath) ?? -1;
                if (index > currentMaxIndex) prePathMaxIndexesMap.set(prePath, index);
              }
            }
          });
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
          if (Object.keys(obj[key]).length === 0) {
            allKeys.add(`${path}${key}`);
          }
          traverse(obj[key], `${path}${key}.`);
        } else {
          allKeys.add(`${path}${key}`);
        }
      }
    }

    data.forEach((item) => traverse(item));
    return Array.from(allKeys).flatMap(key => {
      if (prePathMaxIndexesMap.has(key)) {
        const maxIndex = prePathMaxIndexesMap.get(key);
        return Array.from(Array(maxIndex + 1).keys()).map(index => `${key}.${index}`);
      }
      return key;
    });
  }

  /**
   * Retrieves all values corresponding to keys from nested data.
   */
  function getAllValues(data) {
    const allValues = data.map(item => flattenObject(item));
    return allValues.map((obj) => allKeys.map(key => obj[key] !== undefined ? obj[key] : ""));
  }

  /**
   * Flattens nested objects into key-value pairs.
   */
  function flattenObject(obj, prefix = "") {
    return Object.keys(obj).reduce((acc, key) => {
      const pre = prefix.length ? `${prefix}.` : "";
      const value = obj[key];

      if (Array.isArray(value)) {
        if (value.length === 1 && typeof value[0] !== "object") {
          acc[`${pre}${key}`] = value[0];
        } else {
          value.forEach((item, index) => {
            if (typeof item === "object" && item !== null) {
              Object.assign(acc, flattenObject(item, `${pre}${key}.${index}`));
            } else {
              acc[`${pre}${key}.${index}`] = item;
            }
          });
        }
      } else if (typeof value === "object" && value !== null) {
        Object.assign(acc, flattenObject(value, `${pre}${key}`));
      } else {
        acc[`${pre}${key}`] = value;
      }

      return acc;
    }, {});
  }

  /**
   * Retrieves the current search value from the input field.
   */
  function getSearchValue() {
    return searchInput.value.trim().toLowerCase() ?? "";
  }

  /**
   * Retrieves the state of the UDM list checkbox.
   */
  function getUDMListChecked() {
    return !!predefinedFieldsCheckbox.checked;
  }

  /**
   * Retrieves checkboxes within the dropdown list.
   */
  function getDropdownListCheckboxes() {
    return Array.from(dropdownList.querySelectorAll("[data=\"dropdown-list-checkbox\"]"));
  }

  /**
   * Debounce function execution to optimize performance.
   */
  function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
  }

  /**
   * Generates the dropdown menu based on selected options.
   */
  function generateDropdown() {
    dropdownList.innerHTML = "";
    selectAllText.innerText = "Select all";
    const isUdmListChecked = getUDMListChecked();
    const keysToGenerate = isUdmListChecked ? specifiedKeysInAll : allKeys;
    keysToGenerate.forEach(key => {
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = key;
      checkbox.setAttribute("data", "dropdown-list-checkbox");
      checkbox.checked = true;
      checkbox.addEventListener("change", () => {
        generateTable();
        updateSelectAllCheckbox();
      });
      const label = document.createElement("label");
      label.className = "dropdown-list-label";
      label.setAttribute("data", "dropdown-list-label");
      const labelKey = document.createElement("span");
      label.appendChild(checkbox);
      labelKey.appendChild(document.createTextNode(key));
      renderWithTooltip(labelKey, key);
      label.appendChild(labelKey);
      dropdownList.appendChild(label);
    });
  }

  /**
   * Update the selectAll checkbox state based on individual checkboxes
   */
  function updateSelectAllCheckbox() {
    const checkboxes = getDropdownListCheckboxes();
    const allChecked = checkboxes.every(checkbox => checkbox.checked);
    selectAll.checked = allChecked;
  }

  /**
   * Filters dropdown options based on user input.
   */
  function filterDropdown() {
    const searchTerm = dropdownSearch.value.trim();
    const regex = new RegExp(searchTerm, "gi");
    dropdownList.querySelectorAll("[data=\"dropdown-list-label\"]").forEach(label => {
      const checkbox = label.children[0];
      label.style.display = checkbox?.value.match(regex) ? "flex" : "none";
    });
  }

  /**
   * Creates a tooltip with given text and position.
   */
  function createTooltip(text, x, y, trianglePointX, placeAtBottom, contentOverflowWindow) {
    removeTooltip();
    const tooltip = document.createElement("div");
    tooltip.classList.add("tooltip");
    tooltip.textContent = text;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
    if (contentOverflowWindow) {
      tooltip.style.right = `${tooltipGap}px`;
    }
    const tooltipTriangle = document.createElement("span");
    tooltipTriangle.classList.add("tooltip-triangle");
    tooltipTriangle.style.left = `${trianglePointX}px`;
    if (placeAtBottom) {
      tooltipTriangle.style.top = "-8px";
      tooltipTriangle.style.borderTop = "0";
      tooltipTriangle.style.borderBottom = "solid 8px rgb(195, 210, 232)";
    }
    tooltip.append(tooltipTriangle);
    document.body.append(tooltip);
  }

  /**
   * Removes any existing tooltip from the DOM.
   */
  function removeTooltip() {
    const tooltip = document.querySelectorAll(".tooltip");
    tooltip.forEach((item) => {
      if (item) {
        item.remove();
      }
    });
  }

  /**
   * Sets a timeout to calculate and show tooltip position after a delay.
   */
  function createTooltipListener(event) {
    tooltipTimeout = setTimeout(() => calculateTooltipPosition(event), 1000);
  }

  /**
   * Clears any existing tooltip timeout and removes the tooltip.
   */
  function removeTooltipListener() {
    if (tooltipTimeout) {
      clearTimeout(tooltipTimeout);
    }
    removeTooltip();
  }

  /**
   * Calculates and positions the tooltip relative to the event target.
   */
  function calculateTooltipPosition(event) {
    const target = event.target;
    if (!target) {
      return;
    }
    const viewportWidth = window.innerWidth;
    const rect = target.getBoundingClientRect();
    const tooltipContent = document.createElement("div");
    tooltipContent.classList.add("tooltip");
    tooltipContent.style.top = "0";
    tooltipContent.textContent = target.textContent;
    document.body.appendChild(tooltipContent);
    let contentOverflowWindow = false;
    // Determine if window width would not be enough for content of tooltip
    if (tooltipGap * 2 + tooltipContent.offsetWidth >= viewportWidth) {
      // setting left, right positions to get correct tooltipContentWidth and tooltipContentHeight
      tooltipContent.style.left = `${tooltipGap}px`;
      tooltipContent.style.right = `${tooltipGap}px`;
      contentOverflowWindow = true;
    }
    const tooltipContentWidth = tooltipContent.offsetWidth;
    const tooltipContentHeight = tooltipContent.offsetHeight;
    tooltipContent.remove();
    const elementMidX = rect.left + (rect.width / 2);
    const placeOnRight = elementMidX + tooltipContentWidth / 2 + tooltipGap > viewportWidth;
    const x = Math.max(tooltipGap, placeOnRight ? viewportWidth - tooltipContentWidth - tooltipGap : elementMidX - tooltipContentWidth / 2);
    const placeAtBottom = rect.top < tooltipContentHeight;
    const y = placeAtBottom ? rect.bottom + tooltipTriangleHeight : rect.top - tooltipContentHeight;
    // Calculating trianglePointX relative to window width, to guarantee that it is not out of window
    const trianglePointX = Math.min(Math.max(elementMidX - x, tooltipTriangleMinGap), tooltipContentWidth - tooltipTriangleMinGap - triangleWidth);
    createTooltip(target.textContent, x, y, trianglePointX, placeAtBottom, contentOverflowWindow);
  }

  /**
   * Renders an item with text and sets up tooltip behavior.
   */
  function renderWithTooltip(item, text) {
    item.innerText = text;
    item.classList.add("text-ellipsis");
    tooltipDetectResizeObserver.observe(item);
  }

  /**
   * Function to make a table resizable
   */
  function resizableGrid() {
    const table = document.querySelector(".table");
    if (!table) return;

    const row = table.getElementsByTagName("tr")[0],
      cols = row ? row.children : undefined;
    if (!cols) return;

    for (let i = 0; i < cols.length; i++) {
      const div = createDiv();
      cols[i].appendChild(div);
      cols[i].style.position = "relative";
      setListeners(div);
    }

    function setListeners(div) {
      let pageX, curCol, nxtCol, curColWidth, nxtColWidth, tableWidth;

      div.addEventListener("mousedown", function (e) {
        curCol = e.target.parentElement;
        nxtCol = curCol.nextElementSibling;
        pageX = e.pageX;

        const padding = paddingDiff(curCol);

        curColWidth = curCol.offsetWidth - padding;
        if (nxtCol) {
          nxtColWidth = nxtCol.offsetWidth - padding;
        }
      });

      document.addEventListener("mousemove", function (e) {
        if (curCol) {
          const diffX = e.pageX - pageX;
          if (nxtCol) {
            nxtCol.style.width = nxtColWidth - diffX + "px";
          }
          curCol.style.width = curColWidth + diffX + "px";
          table.style.width = tableWidth + diffX + "px";
        }
      });

      document.addEventListener("mouseup", function () {
        curCol = undefined;
        nxtCol = undefined;
        pageX = undefined;
        nxtColWidth = undefined;
        curColWidth = undefined;
        tableWidth = undefined;
      });
    }

    function createDiv() {
      const div = document.createElement("div");
      div.classList.add("table-resizable-line");
      return div;
    }

    function paddingDiff(col) {
      if (getStyleVal(col, "box-sizing") === "border-box") {
        return 0;
      }

      const padLeft = getStyleVal(col, "padding-left");
      const padRight = getStyleVal(col, "padding-right");
      return parseInt(padLeft) + parseInt(padRight);
    }

    function getStyleVal(elm, css) {
      return window.getComputedStyle(elm, null).getPropertyValue(css);
    }
  }

  window.addEventListener("load", () => {
    // Generate table on page load
    generateTable();
  });
  </script>
 </body>
</html>